# malware_detection_tool.py
import os
import joblib
import tkinter as tk
from tkinter import filedialog, ttk
from datetime import datetime
import pefile
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib import colors

class MalwareDetector:
    def __init__(self):
        self.model = None
        self.scaler = None
        self.selected_features = None
        self.feature_info = None
        self.SUSPICIOUS_EXTENSIONS = {'.exe', '.dll', '.sys', '.ocx', '.com', '.scr', '.bat', '.cmd', '.vbs', '.js', '.zip'}
        self.scan_history = []
        self.load_components()

    def load_components(self):
        try:
            self.model = joblib.load('malware_model.pkl')
            self.scaler = joblib.load('feature_scaler.pkl')
            self.feature_info = joblib.load('feature_info.pkl')
            self.selected_features = joblib.load('selected_features.pkl')
        except Exception as e:
            print(f"Error loading model components: {str(e)}")
            raise

    
    def extract_features(self, file_path):
        try:
            ext = os.path.splitext(file_path.lower())[1]
            if ext not in self.SUSPICIOUS_EXTENSIONS:
                return None, ext

            # Add error handling for corrupted PE files
            try:
                pe = pefile.PE(file_path, fast_load=True)
            except pefile.PEFormatError:
                # Read file as binary and perform basic analysis
                with open(file_path, 'rb') as f:
                    content = f.read()
                
                # Create simplified feature vector for non-PE files
                features = {feature: 0 for feature in self.selected_features}
                features['SectionsMeanEntropy'] = sum(content[i:i+256].count(i) for i in range(256)) / 256
                features['SectionsMinEntropy'] = min(content[i:i+256].count(i) for i in range(256))
                
                return [features[f] for f in self.selected_features], ext

            # Rest of the PE analysis code remains same
            features = {feature: 0 for feature in self.selected_features}
            for feature in self.selected_features:
                if feature in ['SectionsMeanEntropy', 'SectionsMinEntropy']:
                    entropies = [section.get_entropy() for section in pe.sections]
                    if entropies:
                        if feature == 'SectionsMeanEntropy':
                            features[feature] = sum(entropies) / len(entropies)
                        elif feature == 'SectionsMinEntropy':
                            features[feature] = min(entropies)
                elif hasattr(pe.FILE_HEADER, feature):
                    features[feature] = getattr(pe.FILE_HEADER, feature)
                elif hasattr(pe.OPTIONAL_HEADER, feature):
                    features[feature] = getattr(pe.OPTIONAL_HEADER, feature)

            pe.close()
            return [features[f] for f in self.selected_features], ext

        except Exception as e:
            print(f"Error extracting features: {str(e)}")
            return None, ext

    def scan_file(self, file_path):
        try:
            if not os.path.exists(file_path):
                return {'status': 'error', 'message': 'File does not exist'}

            features, ext = self.extract_features(file_path)
            if features is None:
                return {'status': 'info', 'message': f'Unsupported file type: {ext}'}

            features_scaled = self.scaler.transform([features])
            prediction = self.model.predict(features_scaled)[0]
            probability = self.model.predict_proba(features_scaled)[0]

            result = {
                'status': 'success',
                'is_malware': not prediction,
                'confidence': probability[int(not prediction)] * 100,
                'file_type': ext
            }
            self.scan_history.append((file_path, result))
            return result

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def scan_folder(self, folder_path, progress_callback=None):
        results = []
        suspicious_files = [(root, f) for root, _, files in os.walk(folder_path) 
                          for f in files if os.path.splitext(f.lower())[1] in self.SUSPICIOUS_EXTENSIONS]
        
        total_files = len(suspicious_files)
        if not total_files:
            return [{'status': 'info', 'message': 'No suspicious files found', 'file_path': folder_path}]
        
        for idx, (root, file) in enumerate(suspicious_files):
            file_path = os.path.join(root, file)
            try:
                result = self.scan_file(file_path)
                if result:
                    result['file_path'] = file_path
                    results.append(result)
            except Exception as e:
                results.append({
                    'status': 'error',
                    'message': f"Error scanning {file_path}: {str(e)}",
                    'file_path': file_path
                })
            
            if progress_callback:
                progress_callback((idx + 1) / total_files * 100)
                
        return results

    def generate_pdf_report(self, file_path):
        doc = SimpleDocTemplate(file_path, pagesize=letter)
        data = [['File Path', 'Status', 'Confidence', 'File Type']]
        data.extend([
            [result['file_path'],
             'Malware Detected' if result['is_malware'] else 'Clean',
             f"{result['confidence']:.2f}%",
             result['file_type']]
            for _, result in self.scan_history
        ])

        table = Table(data)
        table.setStyle(TableStyle([
            ('BACKGROUND', (0,0), (-1,0), colors.grey),
            ('TEXTCOLOR', (0,0), (-1,0), colors.whitesmoke),
            ('ALIGN', (0,0), (-1,-1), 'CENTER'),
            ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
            ('FONTSIZE', (0,0), (-1,0), 14),
            ('BOTTOMPADDING', (0,0), (-1,0), 12),
            ('BACKGROUND', (0,1), (-1,-1), colors.beige),
            ('GRID', (0,0), (-1,-1), 1, colors.black)
        ]))

        doc.build([table])

class MalwareDetectorGUI:
    def __init__(self):
        self.detector = MalwareDetector()
        self.create_gui()

    def create_gui(self):
        self.root = tk.Tk()
        self.root.title("Malware Detection Tool")
        self.root.geometry("800x600")

        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(main_frame, text="Malware Detection Tool", 
                 font=('Arial', 16, 'bold')).pack(pady=10)

        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)

        for text, command in [("Scan File", self.scan_file), 
                            ("Scan Folder", self.scan_folder),
                            ("Generate Report", self.generate_report)]:
            ttk.Button(button_frame, text=text, command=command).pack(side=tk.LEFT, padx=5)

        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=10)

        self.results_text = tk.Text(main_frame, height=20, wrap=tk.WORD)
        scrollbar = ttk.Scrollbar(main_frame, command=self.results_text.yview)
        self.results_text.configure(yscrollcommand=scrollbar.set)
        
        self.results_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    def display_result(self, result, file_path):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        if result['status'] in ('info', 'error'):
            color = "blue" if result['status'] == 'info' else "red"
            text = f"\n[{timestamp}] {file_path}: {result['message']}\n"
        else:
            color = "red" if result['is_malware'] else "green"
            text = (f"\n[{timestamp}] {file_path}\n"
                   f"Status: {'MALWARE DETECTED' if result['is_malware'] else 'CLEAN'} "
                   f"(Confidence: {result['confidence']:.2f}%)\n"
                   f"File Type: {result['file_type']}\n")

        self.results_text.insert(tk.END, text)
        self.results_text.tag_add(color, "end-%dc" % (len(text) + 1), "end-1c")
        self.results_text.tag_config(color, foreground=color)
        self.results_text.see(tk.END)

    def scan_file(self):
        if file_path := filedialog.askopenfilename(title="Select file to scan"):
            self.progress_var.set(0)
            result = self.detector.scan_file(file_path)
            self.progress_var.set(100)
            self.display_result(result, file_path)

    def scan_folder(self):
        if folder_path := filedialog.askdirectory(title="Select folder to scan"):
            self.progress_var.set(0)
            results = self.detector.scan_folder(folder_path, self.progress_var.set)
            for result in results:
                self.display_result(result, result['file_path'])

    def generate_report(self):
        if report_path := filedialog.asksaveasfilename(
            title="Save Scan Report",
            defaultextension=".pdf",
            filetypes=[("PDF Files", "*.pdf")]
        ):
            self.detector.generate_pdf_report(report_path)

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = MalwareDetectorGUI()
    app.run()