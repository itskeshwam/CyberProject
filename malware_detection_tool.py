import os
from collections import Counter
import joblib
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import sys
from datetime import datetime
import pandas as pd
import numpy as np
from threading import Thread
import queue
import math
import pefile
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib import colors
from reportlab.lib.units import inch
import numpy as np

class MalwareDetector:
    def __init__(self):
        self.model = None
        self.scaler = None
        self.selected_features = None
        self.SUSPICIOUS_EXTENSIONS = {'.exe', '.dll', '.sys', '.ocx', '.com', '.scr', '.bat', '.cmd', '.vbs', '.js'}
        self.scan_history = []
        # Updated feature list to exactly match the model's expectations
        self.default_features = [
            'Machine', 'SizeOfOptionalHeader', 'Characteristics', 'MajorLinkerVersion',
            'MinorLinkerVersion', 'SizeOfCode', 'SizeOfInitializedData', 'SizeOfUninitializedData',
            'SizeOfImage', 'SizeOfHeaders', 'ImageBase', 'SectionAlignment', 'FileAlignment',
            'MajorOperatingSystemVersion', 'MinorOperatingSystemVersion', 'MajorImageVersion',
            'MinorImageVersion', 'MajorSubsystemVersion', 'MinorSubsystemVersion', 'SectionsNb',
            'SectionsMeanEntropy', 'SectionsMinEntropy', 'SectionsMaxEntropy', 'SectionsMeanRawsize',
            'SectionsMinRawsize', 'SectionMaxRawsize', 'SectionsMeanVirtualsize', 'SectionsMinVirtualsize',
            'SectionMaxVirtualsize', 'ImportsNbDLL', 'ImportsNb', 'ImportsNbOrdinal', 'ExportNb',
            'ResourcesNb', 'ResourcesMeanEntropy', 'ResourcesMinEntropy', 'ResourcesMaxEntropy',
            'ResourcesMeanSize', 'ResourcesMinSize', 'ResourcesMaxSize', 'LoadConfigurationSize',
            'VersionInformationSize', 'AddressOfEntryPoint', 'BaseOfCode', 'BaseOfData', 'ImageBase_High',
            'ImageBase_Low', 'NumberOfSections', 'NumberOfSymbols', 'PointerToSymbolTable',
            'TimeDateStamp', 'DllCharacteristics', 'Subsystem', 'CheckSum', 'SizeOfStackReserve'
        ]
        self.load_components()

    def is_pe_file(self, file_path):
        """Check if the file is a PE file"""
        try:
            ext = os.path.splitext(file_path.lower())[1]
            if ext not in self.SUSPICIOUS_EXTENSIONS:
                return False, ext
            
            try:
                pe = pefile.PE(file_path)
                pe.close()
                return True, ext
            except:
                return False, ext
                
        except Exception as e:
            print(f"Error checking PE file {file_path}: {str(e)}")
            return False, None

    def extract_features(self, file_path):
        """Extract features from a file"""
        try:
            is_pe, ext = self.is_pe_file(file_path)
            if not is_pe:
                return None, ext

            pe = pefile.PE(file_path)
            features = {}

            # Initialize all features with default values
            for feature in self.default_features:
                features[feature] = 0

            try:
                # Basic PE Header Features
                features['Machine'] = pe.FILE_HEADER.Machine
                features['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
                features['Characteristics'] = pe.FILE_HEADER.Characteristics
                features['NumberOfSections'] = pe.FILE_HEADER.NumberOfSections
                features['NumberOfSymbols'] = pe.FILE_HEADER.NumberOfSymbols
                features['PointerToSymbolTable'] = pe.FILE_HEADER.PointerToSymbolTable
                features['TimeDateStamp'] = pe.FILE_HEADER.TimeDateStamp

                # Optional Header Features
                if hasattr(pe, 'OPTIONAL_HEADER'):
                    features['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
                    features['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
                    features['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
                    features['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
                    features['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
                    features['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
                    features['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
                    features['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
                    features['ImageBase_High'] = pe.OPTIONAL_HEADER.ImageBase >> 32
                    features['ImageBase_Low'] = pe.OPTIONAL_HEADER.ImageBase & 0xFFFFFFFF
                    features['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
                    features['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
                    features['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
                    features['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
                    features['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
                    features['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
                    features['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
                    features['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
                    features['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
                    features['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
                    features['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
                    features['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
                    features['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
                    features['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
                    if hasattr(pe.OPTIONAL_HEADER, 'BaseOfData'):  # PE32 only
                        features['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData

                # Section Information
                features['SectionsNb'] = len(pe.sections)
                section_entropies = [section.get_entropy() for section in pe.sections]
                section_sizes = [section.SizeOfRawData for section in pe.sections]
                virtual_sizes = [section.Misc_VirtualSize for section in pe.sections]

                if section_entropies:
                    features['SectionsMeanEntropy'] = sum(section_entropies) / len(section_entropies)
                    features['SectionsMinEntropy'] = min(section_entropies)
                    features['SectionsMaxEntropy'] = max(section_entropies)

                if section_sizes:
                    features['SectionsMeanRawsize'] = sum(section_sizes) / len(section_sizes)
                    features['SectionsMinRawsize'] = min(section_sizes)
                    features['SectionMaxRawsize'] = max(section_sizes)

                if virtual_sizes:
                    features['SectionsMeanVirtualsize'] = sum(virtual_sizes) / len(virtual_sizes)
                    features['SectionsMinVirtualsize'] = min(virtual_sizes)
                    features['SectionMaxVirtualsize'] = max(virtual_sizes)

                # Import Information
                if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                    features['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
                    features['ImportsNb'] = sum(len(entry.imports) for entry in pe.DIRECTORY_ENTRY_IMPORT)
                    features['ImportsNbOrdinal'] = sum(1 for entry in pe.DIRECTORY_ENTRY_IMPORT
                                                     for imp in entry.imports if imp.ordinal is not None)

                # Export Information
                if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                    features['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)

                # Resource Information
                if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                    resources = list(pe.DIRECTORY_ENTRY_RESOURCE.entries)
                    features['ResourcesNb'] = len(resources)
                    
                    resource_sizes = []
                    resource_entropies = []
                    for resource in resources:
                        if hasattr(resource, 'directory'):
                            for entry in resource.directory.entries:
                                if hasattr(entry, 'data'):
                                    resource_sizes.append(entry.data.struct.Size)
                                    resource_entropies.append(entry.data.struct.get_entropy())

                    if resource_entropies:
                        features['ResourcesMeanEntropy'] = sum(resource_entropies) / len(resource_entropies)
                        features['ResourcesMinEntropy'] = min(resource_entropies)
                        features['ResourcesMaxEntropy'] = max(resource_entropies)
                    
                    if resource_sizes:
                        features['ResourcesMeanSize'] = sum(resource_sizes) / len(resource_sizes)
                        features['ResourcesMinSize'] = min(resource_sizes)
                        features['ResourcesMaxSize'] = max(resource_sizes)

                # Load Configuration Size
                if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG'):
                    features['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
                
                # Version Information Size
                if hasattr(pe, 'VS_FIXEDFILEINFO'):
                    features['VersionInformationSize'] = pe.VS_FIXEDFILEINFO.Length

            except Exception as e:
                print(f"Warning: Error extracting some features: {str(e)}")

            # Create feature vector in the exact order expected by the model
            feature_vector = []
            for feature_name in self.default_features:
                feature_vector.append(features.get(feature_name, 0))

            pe.close()
            return feature_vector, ext

        except Exception as e:
            print(f"Error extracting features from {file_path}: {str(e)}")
            return None, None


    def load_components(self):
        """Load the trained model and components"""
        try:
            self.model = joblib.load('malware_model.pkl')
            self.scaler = joblib.load('feature_scaler.pkl')
            self.selected_features = joblib.load('selected_features.pkl')
        except FileNotFoundError as e:
            print(f"Error: Required model files not found: {str(e)}")
            print("Please ensure you have run train_model.py first to generate the model files.")
            sys.exit(1)
        except Exception as e:
            print(f"Error: Could not load model components: {str(e)}")
            sys.exit(1)


    def scan_file(self, file_path):
        """Scan a single file for malware"""
        try:
            if not os.path.exists(file_path):
                return {
                    'status': 'error',
                    'message': 'File does not exist',
                    'score': None
                }

            features, ext = self.extract_features(file_path)
            if features is None:
                return {
                    'status': 'info',
                    'message': f'Unsupported file type: {ext}',
                    'score': None
                }

            # Scale features
            features_scaled = self.scaler.transform([features])

            # Get prediction and probability
            prediction = self.model.predict(features_scaled)[0]
            probability = self.model.predict_proba(features_scaled)[0]

            result = {
                'status': 'success',
                'is_malware': not prediction,  # Assuming 0 is malware, 1 is clean
                'confidence': probability[int(not prediction)] * 100,
                'score': probability[1],
                'file_type': ext
            }

            self.scan_history.append((file_path, result))
            return result

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e),
                'score': None
            }

    def scan_folder(self, folder_path, progress_callback=None):
                        """Scan a folder for malware, ignoring common safe file types"""
                        self.scan_history = []
                        results = []
                        
                        # Count only suspicious files for progress
                        total_files = sum(1 for root, _, files in os.walk(folder_path)
                                        for file in files
                                        if os.path.splitext(file.lower())[1] in self.SUSPICIOUS_EXTENSIONS)

                        if total_files == 0:
                            return [{
                                'status': 'info',
                                'message': 'No suspicious files found in the folder',
                                'file_path': folder_path
                            }]
                            
                        processed_files = 0
                        
                        for root, _, files in os.walk(folder_path):
                            for file in files:
                                file_path = os.path.join(root, file)
                                file_ext = os.path.splitext(file.lower())[1]
                                
                                # Skip non-suspicious files
                                if file_ext not in self.SUSPICIOUS_EXTENSIONS:
                                    continue
                                
                                try:
                                    result = self.scan_file(file_path)
                                    if result:
                                        result['file_path'] = file_path
                                        results.append(result)
                                except Exception as e:
                                    results.append({
                                        'status': 'error',
                                        'message': f"Error processing {file_path}: {str(e)}",
                                        'file_path': file_path
                                    })

                                processed_files += 1
                                if progress_callback:
                                    progress_callback(processed_files / total_files * 100)

                        return results

    def generate_pdf_report(self, file_path):
            """Generate a PDF report for the scan history"""
            doc = SimpleDocTemplate(file_path, pagesize=letter)
            elements = []

            data = [['File Path', 'Status', 'Confidence', 'File Type']]
            data.extend([[result['file_path'], 
                        'Malware Detected' if result['is_malware'] else 'Clean', 
                        f"{result['confidence']:.2f}%",
                        result['file_type']] for _, result in self.scan_history])

            table = Table(data)
            table_style = TableStyle([
                ('BACKGROUND', (0,0), (-1,0), colors.grey),
                ('TEXTCOLOR', (0,0), (-1,0), colors.whitesmoke),
                ('ALIGN', (0,0), (-1,-1), 'CENTER'),
                ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
                ('FONTSIZE', (0,0), (-1,0), 14),
                ('BOTTOMPADDING', (0,0), (-1,0), 12),
                ('BACKGROUND', (0,1), (-1,-1), colors.beige),
                ('GRID', (0,0), (-1,-1), 1, colors.black),
            ])

            table.setStyle(table_style)
            
            # 'WIDTHS': (2*[1.5*inch]) + [2*inch]
            elements.append(table)

            doc.build(elements)
            print(f"PDF report generated: {file_path}")

class MalwareDetectorGUI:
    def __init__(self):
        self.detector = MalwareDetector()
        self.create_gui()

    def create_gui(self):
        self.root = tk.Tk()
        self.root.title("Enhanced Malware Detection Tool")
        self.root.geometry("800x600")

        # Style configuration
        style = ttk.Style()
        style.configure('TButton', padding=5)
        style.configure('TProgressbar', thickness=20)

        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Title
        title_label = ttk.Label(main_frame, text="Malware Detection Tool", font=('Arial', 16, 'bold'))
        title_label.pack(pady=10)

        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)

        # Scan buttons
        ttk.Button(button_frame, text="Scan File", command=self.scan_file).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Scan Folder", command=self.scan_folder).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Generate Report", command=self.generate_report).pack(side=tk.LEFT, padx=5)

        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=10)

        # Results frame
        self.results_frame = ttk.Frame(main_frame)
        self.results_frame.pack(fill=tk.BOTH, expand=True)

        # Results text
        self.results_text = tk.Text(self.results_frame, height=20, wrap=tk.WORD)
        self.results_text.pack(fill=tk.BOTH, expand=True)

        # Scrollbar for results
        scrollbar = ttk.Scrollbar(self.results_frame, command=self.results_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_text.config(yscrollcommand=scrollbar.set)

    def update_progress(self, value):
        self.progress_var.set(value)
        self.root.update_idletasks()

    def display_result(self, result, file_path):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if result['status'] == 'info':
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] {file_path}: {result['message']}\n")
            self.results_text.tag_add("info", "end-2c linestart", "end-1c")
            self.results_text.tag_config("info", foreground="blue")
        elif result['status'] == 'error':
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] Error scanning {file_path}: {result['message']}\n")
            self.results_text.tag_add("error", "end-2c linestart", "end-1c")
            self.results_text.tag_config("error", foreground="red")
        else:
            confidence = result['confidence']
            status = "MALWARE DETECTED" if result['is_malware'] else "CLEAN"
            color = "red" if result['is_malware'] else "green"
            
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] {file_path}\n"
                f"Status: {status} (Confidence: {confidence:.2f}%)\n"
                f"File Type: {result['file_type']}\n")
            self.results_text.tag_add(color, "end-4c linestart", "end-1c")
            self.results_text.tag_config(color, foreground=color)

        self.results_text.see(tk.END)

    def scan_file(self):
        file_path = filedialog.askopenfilename(title="Select file to scan")
        if file_path:
            self.progress_var.set(0)
            result = self.detector.scan_file(file_path)
            self.progress_var.set(100)
            self.display_result(result, file_path)

    def scan_folder(self):
        folder_path = filedialog.askdirectory(title="Select folder to scan")
        if folder_path:
            self.progress_var.set(0)
            results = self.detector.scan_folder(folder_path, self.update_progress)
            for result in results:
                self.display_result(result, result['file_path'])
            self.progress_var.set(100)

    def generate_report(self):
        report_path = filedialog.asksaveasfilename(
            title="Save Scan Report",
            defaultextension=".pdf",
            filetypes=[("PDF Files", "*.pdf")]
        )
        if report_path:
            self.detector.generate_pdf_report(report_path)

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = MalwareDetectorGUI()
    app.run()