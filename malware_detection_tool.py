import os
from typing import Counter
import joblib
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import sys
from datetime import datetime
import pandas as pd
import numpy as np
from threading import Thread
import queue
import math
import pefile

class MalwareDetector:
    def __init__(self):
        self.model = None
        self.scaler = None
        self.selected_features = None
        self.load_components()


    def load_components(self):
        """Load the trained model and components"""
        try:
            self.model = joblib.load('malware_model.pkl')
            self.scaler = joblib.load('feature_scaler.pkl')
            self.selected_features = joblib.load('selected_features.pkl')
        except FileNotFoundError as e:
            messagebox.showerror("Error", f"Required model files not found: {str(e)}")
            sys.exit(1)
        except Exception as e:
            messagebox.showerror("Error", f"Error loading model components: {str(e)}")
            sys.exit(1)

    def extract_features(self, file_path):
        """Extract features from a PE file"""
        try:
            pe = pefile.PE(file_path, fast_load=True)

            features = {}

            # Basic file features
            features['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
            features['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
            features['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
            features['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
            features['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
            features['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
            features['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment

            # Section features
            sections = pe.sections
            features['SectionsNb'] = len(sections)

            if len(sections) > 0:
                entropies = [section.get_entropy() for section in sections]
                raw_sizes = [section.SizeOfRawData for section in sections]
                virtual_sizes = [section.Misc_VirtualSize for section in sections]

                features['SectionsMeanEntropy'] = np.mean(entropies)
                features['SectionsMinEntropy'] = min(entropies)
                features['SectionsMaxEntropy'] = max(entropies)
                features['SectionsMeanRawsize'] = np.mean(raw_sizes)
                features['SectionsMinRawsize'] = min(raw_sizes)
                features['SectionMaxRawsize'] = max(raw_sizes)
                features['SectionsMeanVirtualsize'] = np.mean(virtual_sizes)
                features['SectionsMinVirtualsize'] = min(virtual_sizes)
                features['SectionMaxVirtualsize'] = max(virtual_sizes)
            else:
                for feature in ['SectionsMeanEntropy', 'SectionsMinEntropy', 'SectionsMaxEntropy', 'SectionsMeanRawsize', 'SectionsMinRawsize', 'SectionMaxRawsize', 'SectionsMeanVirtualsize', 'SectionsMinVirtualsize', 'SectionMaxVirtualsize']:
                    features[feature] = 0

            # Import features
            try:
                imports = pe.DIRECTORY_ENTRY_IMPORT
                features['ImportsNbDLL'] = len(imports)
                features['ImportsNb'] = sum(len(entry.imports) for entry in imports)
                features['ImportsNbOrdinal'] = sum(imp.ordinal is not None for entry in imports for imp in entry.imports)
            except AttributeError:
                features['ImportsNbDLL'] = 0
                features['ImportsNb'] = 0
                features['ImportsNbOrdinal'] = 0

            # Export features
            try:
                exports = pe.DIRECTORY_ENTRY_EXPORT
                features['ExportNb'] = len(exports.symbols)
            except AttributeError:
                features['ExportNb'] = 0

            # Resource features
            try:
                resources = pe.DIRECTORY_ENTRY_RESOURCE
                resources_data = []
                for resource_type in resources.entries:
                    if hasattr(resource_type, 'directory'):
                        for resource_id in resource_type.directory.entries:
                            if hasattr(resource_id, 'directory'):
                                for resource_lang in resource_id.directory.entries:
                                    data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
                                    resources_data.append(data)

                features['ResourcesNb'] = len(resources_data)
                if resources_data:
                    entropy = [self.calculate_entropy(data) for data in resources_data]
                    sizes = [len(data) for data in resources_data]
                    features['ResourcesMeanEntropy'] = np.mean(entropy)
                    features['ResourcesMinEntropy'] = min(entropy)
                    features['ResourcesMaxEntropy'] = max(entropy)
                    features['ResourcesMeanSize'] = np.mean(sizes)
                    features['ResourcesMinSize'] = min(sizes)
                    features['ResourcesMaxSize'] = max(sizes)
                else:
                    features['ResourcesMeanEntropy'] = 0
                    features['ResourcesMinEntropy'] = 0
                    features['ResourcesMaxEntropy'] = 0
                    features['ResourcesMeanSize'] = 0
                    features['ResourcesMinSize'] = 0
                    features['ResourcesMaxSize'] = 0
            except AttributeError:
                features['ResourcesNb'] = 0
                features['ResourcesMeanEntropy'] = 0
                features['ResourcesMinEntropy'] = 0
                features['ResourcesMaxEntropy'] = 0
                features['ResourcesMeanSize'] = 0
                features['ResourcesMinSize'] = 0
                features['ResourcesMaxSize'] = 0

            # Additional features
            features['LoadConfigurationSize'] = pe.OPTIONAL_HEADER.LoaderFlags
            features['VersionInformationSize'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
            features['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
            features['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
            features['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
            features['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit

            # Prepare features in the correct order
            feature_vector = [features.get(feature, 0) for feature in self.selected_features]
            return feature_vector

        except Exception as e:
            print(f"Error extracting features from {file_path}: {str(e)}")
            return None

    @staticmethod
    def calculate_entropy(data):
        """Calculate Shannon entropy of data"""
        if not data:
            return 0
        occurences = Counter(bytearray(data))
        entropy = 0
        for x in occurences.values():
            p_x = float(x) / len(data)
            entropy -= p_x * math.log(p_x, 2)
        return entropy

    def scan_file(self, file_path):
        """Scan a single file for malware"""
        try:
            features = self.extract_features(file_path)
            if features is None:
                return {
                    'status': 'error',
                    'message': 'Failed to extract features',
                    'score': None
                }

            # Scale features
            features_scaled = self.scaler.transform([features])

            # Get prediction and probability
            prediction = self.model.predict(features_scaled)[0]
            probability = self.model.predict_proba(features_scaled)[0]

            result = {
                'status': 'success',
                'is_malware': not prediction,  # Convert to boolean (1 = legitimate, 0 = malware)
                'confidence': probability[int(not prediction)] * 100,  # Get probability for the prediction
                'score': probability[1]  # Probability of being legitimate
            }

            return result

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e),
                'score': None
            }

    def scan_folder(self, folder_path, progress_callback=None):
        results = []
        total_files = sum(len(files) for _, _, files in os.walk(folder_path))
        processed_files = 0

        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    result = self.scan_file(file_path)
                    if result:  # Check if result is not None
                        result['file_path'] = file_path
                        results.append(result)
                    else:
                        results.append({
                            'status': 'info',
                            'message': f"File {file_path} is not an executable file.",
                            'file_path': file_path
                        })
                except Exception as e:
                    results.append({
                        'status': 'error',
                        'message': f"Error processing {file_path}: {str(e)}",
                        'file_path': file_path
                    })

                processed_files += 1
                if progress_callback:
                    progress_callback(processed_files / total_files * 100)

        return results


class MalwareDetectorGUI:
    def __init__(self):
        self.detector = MalwareDetector()
        self.create_gui()

    def create_gui(self):
        self.root = tk.Tk()
        self.root.title("Enhanced Malware Detection Tool")
        self.root.geometry("600x400")

        # Style configuration
        style = ttk.Style()
        style.configure('TButton', padding=5)
        style.configure('TProgressbar', thickness=20)

        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Title
        title_label = ttk.Label(main_frame, text="Malware Detection Tool", font=('Arial', 16, 'bold'))
        title_label.pack(pady=10)

        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)

        # Scan buttons
        ttk.Button(button_frame, text="Scan File", command=self.scan_file).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Scan Folder", command=self.scan_folder).pack(side=tk.LEFT, padx=5)

        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=10)

        # Results frame
        self.results_frame = ttk.Frame(main_frame)
        self.results_frame.pack(fill=tk.BOTH, expand=True)

        # Results text
        self.results_text = tk.Text(self.results_frame, height=10, wrap=tk.WORD)
        self.results_text.pack(fill=tk.BOTH, expand=True)

        # Scrollbar for results
        scrollbar = ttk.Scrollbar(self.results_frame, command=self.results_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_text.config(yscrollcommand=scrollbar.set)

    def update_progress(self, value):
        self.progress_var.set(value)
        self.root.update_idletasks()

    def display_result(self, result, file_path):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        if result['status'] == 'error':
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] Error scanning {file_path}: {result['message']}\n")
        else:
            confidence = result['confidence']
            status = "MALWARE DETECTED" if result['is_malware'] else "CLEAN"
            color = "red" if result['is_malware'] else "green"

            self.results_text.insert(tk.END,
                f"\n[{timestamp}] {file_path}\n"
                f"Status: {status} (Confidence: {confidence:.2f}%)\n")

        self.results_text.see(tk.END)

    def scan_file(self):
        file_path = filedialog.askopenfilename(title="Select file to scan")
        if file_path:
            self.progress_var.set(0)
            result = self.detector.scan_file(file_path)
            self.progress_var.set(100)
            self.display_result(result, file_path)

    def scan_folder(self):
        folder_path = filedialog.askdirectory(title="Select folder to scan")
        if folder_path:
            self.progress_var.set(0)
            results = self.detector.scan_folder(folder_path, self.update_progress)
            for result in results:
                self.display_result(result, result['file_path'])
            self.progress_var.set(100)

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = MalwareDetectorGUI()
    app.run()