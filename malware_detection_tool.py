import os
import joblib
import tkinter as tk
from tkinter import filedialog, ttk
import sys
from datetime import datetime
import pandas as pd
import pefile
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle
from reportlab.lib import colors
import numpy as np
from sklearn.preprocessing import StandardScaler

class MalwareDetector:
    def __init__(self):
        self.model = None
        self.scaler = None
        self.selected_features = None
        self.feature_info = None
        self.SUSPICIOUS_EXTENSIONS = {'.exe', '.dll', '.sys', '.ocx', '.com', '.scr', '.bat', '.cmd', '.vbs', '.js'}
        self.scan_history = []
        self.load_components()

    def is_pe_file(self, file_path):
        """Check if the file is a PE file"""
        try:
            ext = os.path.splitext(file_path.lower())[1]
            if ext not in self.SUSPICIOUS_EXTENSIONS:
                return False, ext
            
            try:
                pe = pefile.PE(file_path)
                pe.close()
                return True, ext
            except:
                return False, ext
                
        except Exception as e:
            print(f"Error checking PE file {file_path}: {str(e)}")
            return False, None
            
    
    def load_components(self):
        """Load the trained model and components with feature validation"""
        try:
            print("Loading model components...")
            self.model = joblib.load('malware_model.pkl')
            self.scaler = joblib.load('feature_scaler.pkl')
            self.feature_info = joblib.load('feature_info.pkl')
            self.selected_features = joblib.load('selected_features.pkl')
            
            print(f"\nModel loaded successfully:")
            print(f"Using {len(self.selected_features)} selected features")
            print("\nTop 5 most important features:")
            importance_df = pd.DataFrame(self.feature_info['importance_scores'])
            for idx, (feature, importance) in enumerate(zip(
                importance_df['feature'].head(),
                importance_df['importance'].head()
            )):
                print(f"{idx + 1}. {feature:<30} {importance:.4f}")
                
        except FileNotFoundError as e:
            print(f"Error: Required model files not found: {str(e)}")
            sys.exit(1)
        except Exception as e:
            print(f"Error: Could not load model components: {str(e)}")
            sys.exit(1)

    def extract_features(self, file_path):
        """Extract only the selected features from a file"""
        try:
            is_pe, ext = self.is_pe_file(file_path)
            if not is_pe:
                return None, ext

            pe = pefile.PE(file_path)
            features = {}

            # Initialize all selected features with default values
            for feature in self.selected_features:
                features[feature] = 0

            try:
                # Extract only the features that were selected during training
                for feature in self.selected_features:
                    if feature in [
                        'Machine', 'SizeOfOptionalHeader', 'Characteristics',
                        'NumberOfSections', 'NumberOfSymbols', 'PointerToSymbolTable',
                        'TimeDateStamp'
                    ]:
                        features[feature] = getattr(pe.FILE_HEADER, feature)
                    
                    elif hasattr(pe, 'OPTIONAL_HEADER') and hasattr(pe.OPTIONAL_HEADER, feature):
                        features[feature] = getattr(pe.OPTIONAL_HEADER, feature)
                    
                    elif feature.startswith('Sections'):
                        if pe.sections:
                            if 'Entropy' in feature:
                                entropies = [section.get_entropy() for section in pe.sections]
                                if feature == 'SectionsMeanEntropy':
                                    features[feature] = sum(entropies) / len(entropies)
                                elif feature == 'SectionsMinEntropy':
                                    features[feature] = min(entropies)
                                elif feature == 'SectionsMaxEntropy':
                                    features[feature] = max(entropies)
                    
                    # Add other feature extractions based on your selected features
                    
            except Exception as e:
                print(f"Warning: Error extracting feature {feature}: {str(e)}")

            # Create feature vector in the exact order expected by the model
            feature_vector = []
            for feature_name in self.selected_features:
                feature_vector.append(features.get(feature_name, 0))

            pe.close()
            
            if len(feature_vector) != len(self.selected_features):
                raise ValueError(f"Feature vector length mismatch. Expected {len(self.selected_features)}, got {len(feature_vector)}")
                
            return feature_vector, ext

        except Exception as e:
            print(f"Error extracting features from {file_path}: {str(e)}")
            return None, None


    def scan_file(self, file_path):
        """Scan a single file for malware"""
        try:
            if not os.path.exists(file_path):
                return {
                    'status': 'error',
                    'message': 'File does not exist',
                    'score': None
                }

            features, ext = self.extract_features(file_path)
            if features is None:
                return {
                    'status': 'info',
                    'message': f'Unsupported file type: {ext}',
                    'score': None
                }

            # Scale features
            features_scaled = self.scaler.transform([features])

            # Get prediction and probability
            prediction = self.model.predict(features_scaled)[0]
            probability = self.model.predict_proba(features_scaled)[0]

            result = {
                'status': 'success',
                'is_malware': not prediction,  # Assuming 0 is malware, 1 is clean
                'confidence': probability[int(not prediction)] * 100,
                'score': probability[1],
                'file_type': ext
            }

            self.scan_history.append((file_path, result))
            return result

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e),
                'score': None
            }

    def scan_folder(self, folder_path, progress_callback=None):
                        """Scan a folder for malware, ignoring common safe file types"""
                        self.scan_history = []
                        results = []
                        
                        # Count only suspicious files for progress
                        total_files = sum(1 for root, _, files in os.walk(folder_path)
                                        for file in files
                                        if os.path.splitext(file.lower())[1] in self.SUSPICIOUS_EXTENSIONS)

                        if total_files == 0:
                            return [{
                                'status': 'info',
                                'message': 'No suspicious files found in the folder',
                                'file_path': folder_path
                            }]
                            
                        processed_files = 0
                        
                        for root, _, files in os.walk(folder_path):
                            for file in files:
                                file_path = os.path.join(root, file)
                                file_ext = os.path.splitext(file.lower())[1]
                                
                                # Skip non-suspicious files
                                if file_ext not in self.SUSPICIOUS_EXTENSIONS:
                                    continue
                                
                                try:
                                    result = self.scan_file(file_path)
                                    if result:
                                        result['file_path'] = file_path
                                        results.append(result)
                                except Exception as e:
                                    results.append({
                                        'status': 'error',
                                        'message': f"Error processing {file_path}: {str(e)}",
                                        'file_path': file_path
                                    })

                                processed_files += 1
                                if progress_callback:
                                    progress_callback(processed_files / total_files * 100)

                        return results

    def generate_pdf_report(self, file_path):
            """Generate a PDF report for the scan history"""
            doc = SimpleDocTemplate(file_path, pagesize=letter)
            elements = []

            data = [['File Path', 'Status', 'Confidence', 'File Type']]
            data.extend([[result['file_path'], 
                        'Malware Detected' if result['is_malware'] else 'Clean', 
                        f"{result['confidence']:.2f}%",
                        result['file_type']] for _, result in self.scan_history])

            table = Table(data)
            table_style = TableStyle([
                ('BACKGROUND', (0,0), (-1,0), colors.grey),
                ('TEXTCOLOR', (0,0), (-1,0), colors.whitesmoke),
                ('ALIGN', (0,0), (-1,-1), 'CENTER'),
                ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
                ('FONTSIZE', (0,0), (-1,0), 14),
                ('BOTTOMPADDING', (0,0), (-1,0), 12),
                ('BACKGROUND', (0,1), (-1,-1), colors.beige),
                ('GRID', (0,0), (-1,-1), 1, colors.black),
            ])

            table.setStyle(table_style)
            
            # 'WIDTHS': (2*[1.5*inch]) + [2*inch]
            elements.append(table)

            doc.build(elements)
            print(f"PDF report generated: {file_path}")
            
    
    # Load and prepare new data for prediction
    def prepare_data_for_prediction(file_data):
        # Assume `file_data` is a dictionary or DataFrame with all possible features
        # Convert to DataFrame if needed
        if isinstance(file_data, dict):
            data = pd.DataFrame([file_data])  # Convert dict to DataFrame
        else:
            data = file_data

        # Filter to only selected features
        data = data[selected_features]

        # Fill missing values if any, to avoid errors in StandardScaler
        data = data.fillna(0)
        
        # Apply scaling
        data_scaled = scaler.transform(data)

        return data_scaled

    # Example usage in your malware detection tool
    def predict_malware(file_data):
        try:
            # Prepare the data
            data_for_prediction = prepare_data_for_prediction(file_data)
            
            # Predict using the loaded model
            prediction = model.predict(data_for_prediction)
            return prediction
        except Exception as e:
            print("Error in malware prediction:", e)

class MalwareDetectorGUI:
    def __init__(self):
        self.detector = MalwareDetector()
        self.create_gui()

    def create_gui(self):
        self.root = tk.Tk()
        self.root.title("Enhanced Malware Detection Tool")
        self.root.geometry("800x600")

        # Style configuration
        style = ttk.Style()
        style.configure('TButton', padding=5)
        style.configure('TProgressbar', thickness=20)

        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Title
        title_label = ttk.Label(main_frame, text="Malware Detection Tool", font=('Arial', 16, 'bold'))
        title_label.pack(pady=10)

        # Buttons frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(pady=10)

        # Scan buttons
        ttk.Button(button_frame, text="Scan File", command=self.scan_file).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Scan Folder", command=self.scan_folder).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Generate Report", command=self.generate_report).pack(side=tk.LEFT, padx=5)

        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(main_frame, variable=self.progress_var, maximum=100)
        self.progress_bar.pack(fill=tk.X, pady=10)

        # Results frame
        self.results_frame = ttk.Frame(main_frame)
        self.results_frame.pack(fill=tk.BOTH, expand=True)

        # Results text
        self.results_text = tk.Text(self.results_frame, height=20, wrap=tk.WORD)
        self.results_text.pack(fill=tk.BOTH, expand=True)

        # Scrollbar for results
        scrollbar = ttk.Scrollbar(self.results_frame, command=self.results_text.yview)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.results_text.config(yscrollcommand=scrollbar.set)

    def update_progress(self, value):
        self.progress_var.set(value)
        self.root.update_idletasks()

    def display_result(self, result, file_path):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if result['status'] == 'info':
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] {file_path}: {result['message']}\n")
            self.results_text.tag_add("info", "end-2c linestart", "end-1c")
            self.results_text.tag_config("info", foreground="blue")
        elif result['status'] == 'error':
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] Error scanning {file_path}: {result['message']}\n")
            self.results_text.tag_add("error", "end-2c linestart", "end-1c")
            self.results_text.tag_config("error", foreground="red")
        else:
            confidence = result['confidence']
            status = "MALWARE DETECTED" if result['is_malware'] else "CLEAN"
            color = "red" if result['is_malware'] else "green"
            
            self.results_text.insert(tk.END,
                f"\n[{timestamp}] {file_path}\n"
                f"Status: {status} (Confidence: {confidence:.2f}%)\n"
                f"File Type: {result['file_type']}\n")
            self.results_text.tag_add(color, "end-4c linestart", "end-1c")
            self.results_text.tag_config(color, foreground=color)

        self.results_text.see(tk.END)

    def scan_file(self):
        file_path = filedialog.askopenfilename(title="Select file to scan")
        if file_path:
            self.progress_var.set(0)
            result = self.detector.scan_file(file_path)
            self.progress_var.set(100)
            self.display_result(result, file_path)

    def scan_folder(self):
        folder_path = filedialog.askdirectory(title="Select folder to scan")
        if folder_path:
            self.progress_var.set(0)
            results = self.detector.scan_folder(folder_path, self.update_progress)
            for result in results:
                self.display_result(result, result['file_path'])
            self.progress_var.set(100)

    def generate_report(self):
        report_path = filedialog.asksaveasfilename(
            title="Save Scan Report",
            defaultextension=".pdf",
            filetypes=[("PDF Files", "*.pdf")]
        )
        if report_path:
            self.detector.generate_pdf_report(report_path)

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = MalwareDetectorGUI()
    app.run()